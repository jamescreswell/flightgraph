{% extends 'flights/base.html' %}
{% load static %}

{% block links %}
<script type='text/javascript' src='http://d3js.org/d3.v3.min.js'></script>
<script type='text/javascript' src='http://d3js.org/topojson.v1.min.js'></script>
<script type='text/javascript' src="{% static 'flights/geo/planetaryjs.min.js' %}"></script>
{% endblock %}

{% block content %}
<div class="center">
    <h1>Welcome to 54.91.110.22:8000</h1>
    <span>Commercial flight visualisation for aviation enthusiasts<!--Plot flight paths, look up airports, and save your flight history.--></span>
</div>

<canvas id="rotatingGlobe"></canvas>

<script type='text/javascript'>
            (function() {
              var globe = planetaryjs.planet();
                
                globe.loadPlugin(autocenter({extraHeight: -120}));
                globe.loadPlugin(autoscale({extraHeight: -120}));
              globe.loadPlugin(autorotate(2));
              // The `earth` plugin draws the oceans and the land; it's actually
              // a combination of several separate built-in plugins.
              //
              // Note that we're loading a special TopoJSON file
              // (world-110m-withlakes.json) so we can render lakes.
              globe.loadPlugin(planetaryjs.plugins.earth({
                topojson: { file:   "{% static 'flights/geo/world-110m.json' %}" },
                oceans:   { fill:   '#7394bc' },
                land:     { fill:   '#ccc6b3' },//'#06304e' },
                borders:  { stroke: '#6e7a8c' }
              }));
              // The `pings` plugin draws animated pings on the globe.
              globe.loadPlugin(planetaryjs.plugins.pings());
              // The `zoom` and `drag` plugins enable
              // manipulating the globe with the mouse.
              //globe.loadPlugin(planetaryjs.plugins.zoom({
                  //scaleExtent: [50, 1000]
             // }));
              //globe.loadPlugin(planetaryjs.plugins.drag({
                // Dragging the globe should pause the
                // automatic rotation until we release the mouse.
                //onDragStart: function() {
                //  this.plugins.autorotate.pause();
                //},
                //onDragEnd: function() {
                //  this.plugins.autorotate.resume();
                //}
              //}));
                
              // Set up the globe's initial scale, offset, and rotation.
              globe.projection.scale(175).translate([175, 175]).rotate([0, -10, 0]);

              // Every few hundred milliseconds, we'll draw another random ping.
              var colors = ['red', 'yellow', 'white', 'orange', 'green', 'cyan', 'pink'];
              //setInterval(function() {
            //    var lat = Math.random() * 170 - 85;
            //    var lng = Math.random() * 360 - 180;
            //    var color = colors[Math.floor(Math.random() * colors.length)];
            //    globe.plugins.pings.add(lng, lat, { color: color, ttl: 2000, angle: Math.random() * 10 });
            //  }, 150);

              var canvas = document.getElementById('rotatingGlobe');
                
              globe.draw(canvas);

                
                
              // This plugin will automatically rotate the globe around its vertical
              // axis a configured number of degrees every second.
              function autorotate(degPerSec) {
                // Planetary.js plugins are functions that take a `planet` instance
                // as an argument...
                return function(planet) {
                  var lastTick = null;
                  var paused = false;
                  planet.plugins.autorotate = {
                    pause:  function() { paused = true;  },
                    resume: function() { paused = false; }
                  };
                  // ...and configure hooks into certain pieces of its lifecycle.
                  planet.onDraw(function() {
                    if (paused || !lastTick) {
                      lastTick = new Date();
                    } else {
                      var now = new Date();
                      var delta = now - lastTick;
                      // This plugin uses the built-in projection (provided by D3)
                      // to rotate the globe each time we draw it.
                      var rotation = planet.projection.rotate();
                      rotation[0] += degPerSec * delta / 1000;
                      if (rotation[0] >= 180) rotation[0] -= 360;
                      planet.projection.rotate(rotation);
                      lastTick = now;
                    }
                  });
                };
              };
                
                
                
                // Plugin to resize the canvas to fill the window and to
                  // automatically center the planet when the window size changes
                  function autocenter(options) {
                    options = options || {};
                    var needsCentering = false;
                    var globe = null;

                    var resize = function() {
                      var width  = window.innerWidth + (options.extraWidth || 0);
                      var height = window.innerHeight + (options.extraHeight || 0);
                      globe.canvas.width = width;
                      globe.canvas.height = height;
                      globe.projection.translate([width / 2, height / 2]);
                    };

                    return function(planet) {
                      globe = planet;
                      planet.onInit(function() {
                        needsCentering = true;
                        d3.select(window).on('resize', function() {
                          needsCentering = true;
                        });
                      });

                      planet.onDraw(function() {
                        if (needsCentering) { resize(); needsCentering = false; }
                      });
                    };
                  };

                  // Plugin to automatically scale the planet's projection based
                  // on the window size when the planet is initialized
                  function autoscale(options) {
                    options = options || {};
                    return function(planet) {
                      planet.onInit(function() {
                        var width  = window.innerWidth + (options.extraWidth || 0);
                        var height = window.innerHeight + (options.extraHeight || 0);
                        planet.projection.scale(Math.min(width, height) / 2);
                      });
                    };
                  };
            })();
        </script>
{% endblock %}